# Get the population values
PV <- as.numeric(condition$pop_tab$pv)[condition$est_tab$free]
par <- paste0(
condition$pop_tab$lhs[condition$est_tab$free],
condition$pop_tab$op[condition$est_tab$free],
condition$pop_tab$rhs[condition$est_tab$free]
)
n_pars <- length(PV)
n_pars
# Memory allocation
coefs <- SEs <- cvr_r <- acc_r <- matrix(NA, nrow = n_pars, ncol = reps)
sigs <- cover <- matrix(FALSE, nrow = n_pars, ncol = reps)
errors <- warnings <- not_converged <- inadmissible <- rep(FALSE, times = reps)
r = 1
dat <- lavaan::simulateData(
model = condition$pop_synt,
sample.nobs = condition$sample_size,
skewness = condition$skewness,
kurtosis = condition$kurtosis
)
fit <- tryCatch({
suppressWarnings(
lavaan(
model = condition$est_synt,
data = dat,
estimator = estimator,
bounds = bounds,
warn = FALSE,
check.start = FALSE
)
)
},
error = function(e) {
errors[r] <<- TRUE
not_converged[r] <<- TRUE
NULL
}
)
if (is.null(fit) || !lavInspect(fit, what = "converged")) {
not_converged[r] <- TRUE
next # Estimates from non-converged replications are not included in results
}
if (!suppressWarnings(lavInspect(fit, what = "post.check"))) {
inadmissible[r] <- TRUE
}
parameterEstimates(fit, remove.nonfree = TRUE)$est
parameterEstimates(fit, remove.nonfree = TRUE)
parameterEstimates(fit, remove.nonfree = TRUE)$est[1:n_pars]
parameterEstimates(fit, remove.nonfree = TRUE)$est
parameterEstimates(fit, remove.nonfree = TRUE)
coefs[, r] <- parameterEstimates(fit, remove.nonfree = TRUE)$est[1:n_pars]
SEs[, r] <- parameterEstimates(fit, remove.nonfree = TRUE)$se[1:n_pars]
sigs[, r] <- parameterEstimates(fit, remove.nonfree = TRUE)$pvalue[1:n_pars] < condition$alpha
cvr_r[, r] <- suppressWarnings({
parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.lower[1:n_pars] < PV &
parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.upper[1:n_pars] > PV
})
acc_r[, r] <- parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.upper[1:n_pars] -
parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.lower[1:n_pars]
# Start simulation
for (r in 1:reps) {
dat <- lavaan::simulateData(
model = condition$pop_synt,
sample.nobs = condition$sample_size,
skewness = condition$skewness,
kurtosis = condition$kurtosis
)
fit <- tryCatch({
suppressWarnings(
lavaan(
model = condition$est_synt,
data = dat,
estimator = estimator,
bounds = bounds,
warn = FALSE,
check.start = FALSE
)
)
},
error = function(e) {
errors[r] <<- TRUE
not_converged[r] <<- TRUE
NULL
}
)
if (is.null(fit) || !lavInspect(fit, what = "converged")) {
not_converged[r] <- TRUE
next # Estimates from non-converged replications are not included in results
}
if (!suppressWarnings(lavInspect(fit, what = "post.check"))) {
inadmissible[r] <- TRUE
}
# Get estimates
tryCatch({
coefs[, r] <- parameterEstimates(fit, remove.nonfree = TRUE)$est[1:n_pars]
SEs[, r] <- parameterEstimates(fit, remove.nonfree = TRUE)$se[1:n_pars]
sigs[, r] <- parameterEstimates(fit, remove.nonfree = TRUE)$pvalue[1:n_pars] < condition$alpha
cvr_r[, r] <- suppressWarnings({
parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.lower[1:n_pars] < PV &
parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.upper[1:n_pars] > PV
})
acc_r[, r] <- parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.upper[1:n_pars] -
parameterEstimates(fit, remove.nonfree = TRUE, level = (1 - condition$alpha))$ci.lower[1:n_pars]
},
error = function(e) {
errors[r] <<- TRUE
not_converged[r] <<- TRUE
}
)
}
# Compute simulation results
converged_reps <- reps - sum(not_converged)
min <- suppressWarnings({apply(coefs, 1, min, na.rm = TRUE)})
avg <- rowMeans(coefs, na.rm = TRUE)
stdDev <- apply(coefs, 1, stats::sd, na.rm = TRUE)
SEAvg <- rowMeans(SEs, na.rm = TRUE)
MSE <- rowMeans((coefs - PV)^2, na.rm = TRUE)
acc <- rowSums(acc_r, na.rm = TRUE) / converged_reps
pwr <- rowSums(sigs, na.rm = TRUE) / converged_reps
cvr <- rowSums(cvr_r, na.rm = TRUE) / converged_reps
# Quantify uncertainty around pwr using bootstrapping
Pow_uncertainty <- t(
apply(sigs, 1, quantify_uncertainty,
bootstrap_reps = bootstrap_reps,
converged_reps = converged_reps
)
)
# Structure results
condition$estimates <- data.frame(
Par = par,
PV = PV,
Avg = avg,
Min = min,
stdDev, SEAvg, MSE,
Acc = acc,
Cov = cvr,
Pow = pwr
)
condition$uncertainty <- data.frame(par, Pow2.5 = Pow_uncertainty[, "2.5%"], Pow97.5 = Pow_uncertainty[, "97.5%"])
condition$errors <- errors
condition$not_converged <- not_converged
condition$inadmissible <- inadmissible
# Include constraints
out4 <- powRICLPM(
target_power = 0.8,
sample_size = c(200, 300),
time_points = 4,
ICC = .5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 1234,
constraints = "stationarity"
)
library(devtools)
install()
# Test run() ----
library(devtools)
load_all()
library(powRICLPM)
# Include constraints
out4 <- powRICLPM(
target_power = 0.8,
sample_size = c(200, 300),
time_points = 4,
ICC = .5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 1234,
constraints = "stationarity"
)
out4
plot(out4)
plot(out4, parameter = "wB2~wA1")
give(out4, "estimates")
give(out4, "results")
give(out4, "results", parameter = "wB2~wA1")
# Create valid powRICLPM() input
Phi <- matrix(c(0.4, 0.15, 0.2, 0.3), ncol = 2, byrow = TRUE)
wSigma <- matrix(c(1, 0.3, 0.3, 1), ncol = 2, byrow = TRUE)
out1 <- powRICLPM(
target_power = 0.8,
sample_size = 21,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10,
seed = 123456,
bounds = FALSE
)
out1 <- powRICLPM(
target_power = 0.8,
sample_size = 21,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 123456,
bounds = FALSE
)
out1 <- powRICLPM(
target_power = 0.8,
sample_size = 21,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10,
seed = 123456,
bounds = FALSE
)
out2 <- powRICLPM(
target_power = 0.8,
sample_size = 21,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10,
seed = 123456,
bounds = TRUE
)
expect_equal(class(out2), c("powRICLPM", "list"))
expect_equal(names(out2), c("conditions", "session"))
expect_equal(
c("estimates", "uncertainty", "errors", "not_converged", "inadmissible") %in% names(out1$conditions[[1]]),
c(T, T, T, T, T)
)
expect_type(out2$conditions[[1]]$estimates, "list")
expect_type(out2$conditions[[1]]$uncertainty, "list")
expect_type(out2$conditions[[1]]$errors, "logical")
expect_type(out2$conditions[[1]]$not_converged, "logical")
expect_type(out2$conditions[[1]]$inadmissible, "logical")
# Test "session" element
expect_true(out2$session$bounds)
# Test that bounded estimation works
expect_true(sum(out1$conditions[[1]]$not_converged) > sum(out2$conditions[[1]]$not_converged))
# Create valid powRICLPM() input
Phi <- matrix(c(0.4, 0.15, 0.2, 0.3), ncol = 2, byrow = TRUE)
wSigma <- matrix(c(1, 0.3, 0.3, 1), ncol = 2, byrow = TRUE)
out1 <- powRICLPM(
target_power = 0.8,
sample_size = 300,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 123456,
bounds = FALSE,
constraints = "lagged"
)
expect_equal(
out1$conditions[[1]]$results$avg[which(out1$conditions[[1]]$results$par == "wB2~wA1")],
out1$conditions[[1]]$results$avg[which(out1$conditions[[1]]$results$par == "wB3~wA2")]
)
out2 <- powRICLPM(
target_power = 0.8,
sample_size = 300,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 123456,
bounds = FALSE,
constraints = "residuals"
)
expect_equal(
out2$conditions[[1]]$results$avg[which(out2$conditions[[1]]$results$par == "wA2~~wA2")],
out2$conditions[[1]]$results$avg[which(out2$conditions[[1]]$results$par == "wA3~~wA3")]
)
out3 <- powRICLPM(
target_power = 0.8,
sample_size = 300,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 123456,
bounds = FALSE,
constraints = "within"
)
expect_equal(
out3$conditions[[1]]$results$avg[which(out3$conditions[[1]]$results$par == "wB2~wA1")],
out3$conditions[[1]]$results$avg[which(out3$conditions[[1]]$results$par == "wB3~wA2")]
)
expect_equal(
out3$conditions[[1]]$results$avg[which(out3$conditions[[1]]$results$par == "wA2~~wA2")],
out3$conditions[[1]]$results$avg[which(out3$conditions[[1]]$results$par == "wA3~~wA3")]
)
out4 <- powRICLPM(
target_power = 0.8,
sample_size = 300,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 123456,
bounds = FALSE,
constraints = "stationarity"
)
expect_equal(
out4$conditions[[1]]$results$avg[which(out4$conditions[[1]]$results$par == "wB2~wA1")],
out4$conditions[[1]]$results$avg[which(out4$conditions[[1]]$results$par == "wB3~wA2")],
tolerance = 1e06
)
# Create valid powRICLPM() input
Phi <- matrix(c(0.4, 0.15, 0.2, 0.3), ncol = 2, byrow = TRUE)
wSigma <- matrix(c(1, 0.3, 0.3, 1), ncol = 2, byrow = TRUE)
# Base condition - Single experimental condition
out1 <- powRICLPM(
target_power = 0.8,
sample_size = c(300, 400),
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 2,
seed = 123456
)
expect_snapshot(summary(out1))
expect_snapshot(summary(out1, parameter = "wB2~wA1"))
expect_snapshot(summary(out1, names = TRUE))
snapshot_accept('summary')
?give()
# Run power analyses
out_noBound <- powRICLPM(target_power = 0.8,
sample_size = 30
time_points = c3,
# Run power analyses
out_noBound <- powRICLPM(target_power = 0.8,
sample_size = 30,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10)
out_bounds <- powRICLPM(target_power = 0.8,
sample_size = 30,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10,
bounds = TRUE)
# Run power analyses
out_noBound <- powRICLPM(target_power = 0.8,
sample_size = 30,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10,
seed = 123456)
out_bounds <- powRICLPM(target_power = 0.8,
sample_size = 30,
time_points = 3,
ICC = 0.5,
RI_cor = 0.3,
Phi = Phi,
wSigma = wSigma,
reps = 10,
bounds = TRUE,
seed = 123456)
# Inspect convergence issues
give(out_bounds, "estimation_problems")
# Inspect convergence issues
give(out_noBounds, "estimation_problems")
# Inspect convergence issues
give(out_noBound, "estimation_problems")
give(out_bounds, "estimation_problems")
# Inspect convergence issues
give(out_noBound, "estimation_problems")
give(out_bounds, "estimation_problems")
out_noBound
give(out_noBound, "results", parameter = 'wB2~wA1')
?powRICLPM
check()
?quantile
library(usethis)
use_package("stats")
?furrr
library(pkgdown)
build_site()
check()
tools:::.check_packages_used_in_tests(dir = ".", testdir = "tests/testthat")
?tools
?tools::.check_packages_used_in_tests
library(help = "tools")
library(tools)
checkTnF()
?checkTnF
rm(list = ls())
?tools::.check_packages_used_in_tests
tools::.check_packages_used_in_tests
tools:::.check_packages_used_in_tests
tools:::.check_packages_used_in_tests()
?getwd()
getwd()
tools:::.check_packages_used_in_tests(dir = ".", testdir = "tests/testthat")
check_packages_in_dir("tests/testthat")
check()
check()
# Matrix of standardized lagged effects
Phi <- matrix(c(0.20, 0.10, 0.15, 0.30), byrow = FALSE, ncol = 2)
# Correlation matrix of within-components
wSigma <- matrix(c(1, 0.26, 0.26, 1), byrow = FALSE, ncol = 2)
# Setup parallel processing to speed up computations
plan(multisession, workers = 6)
# Perform preliminary power analysis (with progress bar)
with_progress({
out_preliminary <- powRICLPM(target_power = 0.8,
search_lower = 200,
search_upper = 2000,
search_step = 100,
time_points = c(3, 4, 5),
ICC = c(0.3, 0.5, 0.7),
RI_cor = 0.35,
Phi = Phi,
wSigma = wSigma,
reps = 100,
seed = 123456)
})
library(powRICLPM)
library(ggplot2)
library(furrr)
library(progressr)
# Perform preliminary power analysis (with progress bar)
with_progress({
out_preliminary <- powRICLPM(target_power = 0.8,
search_lower = 200,
search_upper = 2000,
search_step = 100,
time_points = c(3, 4, 5),
ICC = c(0.3, 0.5, 0.7),
RI_cor = 0.35,
Phi = Phi,
wSigma = wSigma,
reps = 100,
seed = 123456)
})
getwd()
saveRDS(out_preliminary)
saveRDS(out_preliminary, file = ""C:/Users/5879167/surfdrive/R packages/powRICLPM"/out_preliminary")
saveRDS(out_preliminary, file = "C:/Users/5879167/surfdrive/R packages/powRICLPM"/out_preliminary")
saveRDS(out_preliminary, file = "C:/Users/5879167/surfdrive/R packages/powRICLPM"/out_preliminary")
saveRDS(out_preliminary, file = "C:/Users/5879167/surfdrive/R packages/powRICLPM/out_preliminary")
# Tabular summary of results
summary(out_preliminary)
res_wB2wA1 <- give(out_preliminary, what = "results" parameter = "wB2~wA1")
res_wB2wA1 <- give(out_preliminary, what = "results",parameter = "wB2~wA1")
View(res_wB2wA1)
# Visualize power
p <- plot(x = out_preliminary, parameter = "wB2~wA1")
# Tailor visualization for Mulder (under review)
p <- p +
labs(color = "Number of time points") +
scale_x_continuous(name = "Sample size",
breaks = seq(200, 2000, 200),
guide = guide_axis(n.dodge = 2)) +
theme(legend.position = "bottom")
p
ggsave("Mulder2022_preliminary_power.png", height = 5, width = 7)
getwd()
ggsave("Mulder2022_preliminary_power.png", height = 5, width = 7)
?ggsave
# Visualize accuracy
a <- plot_powRICLPM(out_preliminary,
"sample_size",
"acc",
color = "factor(time_points)",
wrap = "ICC",
parameter = "wB2~wA1")
?ggplot2::position_dodge
# Setup parallel processing to speed up computations
plan(multisession, workers = 6)
# Perform preliminary power analysis (with progress bar)
with_progress({
out_validation <- powRICLPM(target_power = 0.8,
search_lower = 900,
search_upper = 1800,
search_step = 100,
time_points = c(4, 5),
ICC = c(0.3, 0.5, 0.7),
RI_cor = 0.35,
Phi = Phi,
wSigma = wSigma,
reps = 2000,
seed = 123456)
})
plot(out_validation, parameter = "wB2~wA1")
saveRDS(out_validation, file = "out_validation")
